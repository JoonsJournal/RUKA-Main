#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ROHand Gesture Control - 손동작 인식 기반 로봇 손 제어 프로그램
이 프로그램은 웹캠을 통해 사용자의 손동작을 실시간으로 인식하고,
인식된 제스처에 따라 ROHand(로봇 손)를 제어합니다.
주요 기능:
1. MediaPipe 기반 실시간 손 추적 (최대 30fps)
2. 6가지 제스처 패턴 인식 (주먹, 1~5개 손가락)
3. 멀티스레딩을 통한 병렬 처리 (카메라 + 제어)
4. 엄지 간섭 방지 알고리즘
5. 제스처 아이콘 실시간 표시

기술 스택:
- OpenCV: 카메라 영상 처리
- MediaPipe: 손 랜드마크 추적
- PyModbus: ROHand 제어
- Threading: 병렬 처리

작성일: 2024
라이선스: OY Motion
"""

# =============================================================================

# 라이브러리 임포트

# =============================================================================

import os              # 파일 경로 처리
import sys             # 시스템 경로 조작
import cv2             # OpenCV: 영상 처리 및 카메라 입력
import time            # 시간 측정 및 지연
import queue           # 스레드 간 데이터 전달용 큐
import threading       # 멀티스레딩 (카메라와 제어 분리)

# ModBus 통신 관련

from pymodbus import FramerType
from pymodbus.client import ModbusSerialClient
from pymodbus.exceptions import ModbusException
from serial.tools import list_ports

# =============================================================================
# 프로젝트 모듈 임포트
# =============================================================================

# 상위 디렉토리의 공통 모듈 경로 추가
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# 손 추적 모듈 (같은 디렉토리)
from HandTrackingModule import HandDetector

# ROHand 레지스터 정의 (상위 디렉토리 common/)
from common.roh_registers_v1 import *

# =============================================================================
# 전역 변수 및 설정
# =============================================================================

# 현재 스크립트의 절대 경로 (제스처 이미지 파일 로드용)
file_path = os.path.abspath(os.path.dirname(__file__))

# === ROHand 설정 ===
NUM_FINGERS = 6         # 제어할 손가락 개수 (엄지~새끼 5개 + 엄지 루트 1개)
NODE_ID = 2             # ROHand의 ModBus 노드 ID (기본값: 2)

# =============================================================================
# 스레드 간 통신용 큐 (Thread-Safe)

# =============================================================================
# 제스처 데이터를 카메라 스레드 → 메인 스레드로 전달
# maxsize=NUM_FINGERS: 최대 6개의 제스처 데이터 저장 가능
gesture_queue = queue.Queue(maxsize=NUM_FINGERS)

# 카메라 이미지를 카메라 스레드 → 메인 스레드로 전달
# maxsize=1: 최신 이미지 1개만 저장 (오래된 이미지는 버림)
image_queue = queue.Queue(maxsize=1)

# =============================================================================
# 카메라 초기화
# =============================================================================

# VideoCapture(0): 기본 웹캠 사용
# 다른 카메라 사용 시 0 → 1, 2 등으로 변경
video = cv2.VideoCapture(0)

# 카메라 해상도 가져오기
width = int(video.get(cv2.CAP_PROP_FRAME_WIDTH))    # 예: 640
height = int(video.get(cv2.CAP_PROP_FRAME_HEIGHT))  # 예: 480
print(f"카메라 해상도: {width} x {height}")

# =============================================================================
# 손 추적기 초기화
# =============================================================================

# HandDetector: MediaPipe 기반 손 추적 클래스
# - maxHands=1: 한 손만 추적 (성능 최적화)
# - detectionCon=0.8: 검출 신뢰도 임계값 (높을수록 정확, 낮을수록 민감)
detector = HandDetector(maxHands=1, detectionCon=0.8)

# =============================================================================
# OpenCV 윈도우 설정
# =============================================================================
# WINDOW_NORMAL: 창 크기 조절 가능
cv2.namedWindow("Video", cv2.WINDOW_NORMAL)

# 윈도우 크기를 카메라 해상도에 맞춤
cv2.resizeWindow("Video", width, height)

# =============================================================================
# 유틸리티 함수
# =============================================================================

def find_comport(port_name):
    """
    시리얼 포트 자동 감지 함수
    
    시스템에 연결된 모든 시리얼 포트를 스캔하여
    지정된 이름이 포함된 포트를 찾습니다.
    
    Parameters:
    -----------
    port_name : str
        찾을 포트의 특징 문자열 (예: "CH340", "USB")
    
    Returns:
    --------
    str or None
        찾은 포트 경로 또는 None
    
    예시:
    -----
    port = find_comport("CH340")
    # Windows: "COM3" 반환
    # Linux:   "/dev/ttyUSB0" 반환
    """
    # 시스템의 모든 시리얼 포트 목록 가져오기
    ports = list_ports.comports()
    
    # 각 포트를 순회하며 검색
    for port in ports:
        # 포트 설명(description)에 찾는 문자열이 포함되어 있는지 확인
        if port_name in port.description:
            print(f"✓ 포트 발견: {port.device} ({port.description})")
            return port.device
    
    # 찾지 못한 경우
    print(f"✗ '{port_name}' 포트를 찾을 수 없습니다.")
    return None


def write_registers(client, address, values):
    """
    ModBus 레지스터에 데이터 쓰기 (ROHand 제어 명령 전송)
    
    ROHand의 손가락 목표 위치를 설정하는 핵심 함수입니다.
    
    Parameters:
    -----------
    client : ModbusSerialClient
        ModBus 통신 클라이언트 객체
    address : int
        쓸 레지스터의 시작 주소
        예: ROH_FINGER_POS_TARGET0 (1135)
    values : list of int
        쓸 데이터 리스트 (각 손가락의 목표 위치)
        예: [45000, 65535, 0, 0, 0, 0]
            엄지=45000(반쯤), 검지=65535(접힘), 나머지=0(펴짐)
    
    Returns:
    --------
    bool
        True: 쓰기 성공
        False: 쓰기 실패
    
    값 범위:
    --------
    0      = 손가락 완전히 펴짐
    32767  = 손가락 반쯤 접힘
    65535  = 손가락 완전히 접힘
    """
    try:
        # ModBus write_registers 함수 호출
        # - address: 시작 레지스터 주소
        # - values: 쓸 값들의 리스트
        # - NODE_ID: 대상 ROHand의 노드 ID
        resp = client.write_registers(address, values, NODE_ID)
        
        # 응답 에러 체크
        if resp.isError():
            print(f"✗ 레지스터 쓰기 실패: {resp}")
            return False
        
        return True
        
    except ModbusException as e:
        # ModBus 통신 예외 처리
        print(f"✗ ModBus 예외 발생: {e}")
        return False


def read_registers(client, address, count):
    """
    ModBus 레지스터에서 데이터 읽기 (ROHand 상태 확인)
    
    현재 손가락의 위치, 속도, 전류 등을 읽을 수 있습니다.
    (이 프로그램에서는 사용하지 않지만, 디버깅 시 유용)
    
    Parameters:
    -----------
    client : ModbusSerialClient
        ModBus 통신 클라이언트 객체
    address : int
        읽을 레지스터의 시작 주소
        예: ROH_FINGER_POS0 (1145) = 현재 위치
    count : int
        읽을 레지스터 개수
    
    Returns:
    --------
    list of int or None
        읽은 레지스터 값들 또는 None (실패 시)
    """
    try:
        # ModBus read_holding_registers 함수 호출
        resp = client.read_holding_registers(address, count, NODE_ID)
        
        # 응답 에러 체크
        if resp.isError():
            print("✗ 레지스터 읽기 실패")
            return None
        
        # 읽은 레지스터 값 반환
        return resp.registers
        
    except ModbusException as e:
        # ModBus 통신 예외 처리
        print(f"✗ ModBus 예외 발생: {e}")
        return None


# =============================================================================
# 카메라 스레드 함수 (별도 스레드에서 실행)
# =============================================================================

def camera_thread():
    """
    카메라 영상 처리 및 손 추적 스레드
    
    이 함수는 메인 스레드와 독립적으로 실행되어
    카메라에서 영상을 받아 손을 추적하고 제스처를 인식합니다.
    
    동작 흐름:
    ----------
    1. 카메라에서 프레임 읽기 (30fps)
    2. 이미지 좌우 반전 (거울 효과)
    3. 손 검출 및 랜드마크 추출
    4. 손가락 펴짐/접힘 상태 계산
    5. 제스처 패턴 인식
    6. 제스처 → ROHand 값 매핑
    7. 엄지 간섭 방지 처리
    8. 결과를 큐에 전달
    
    스레드 특성:
    -----------
    - 무한 루프로 계속 실행
    - daemon=True로 설정되어 메인 종료 시 자동 종료
    - 큐를 통해 메인 스레드와 통신
    
    성능:
    -----
    - 처리 속도: ~30fps (카메라 속도에 의존)
    - CPU 사용: 20~40% (1개 코어)
    """
    
    # =========================================================================
    # 엄지 간섭 방지 변수 초기화
    # =========================================================================
    # 엄지와 다른 손가락이 동시에 움직일 때 발생하는 오동작을 방지
    timer = 0                   # 타이머 카운터
    interval = 10               # 지연 프레임 수 (10프레임 = 약 0.3초)
    original_thumb_pos = 0      # 원래 엄지 위치 저장
    prev_index_pos = 0          # 이전 검지 위치 (변화 감지용)
    
    # =========================================================================
    # 무한 루프: 카메라 프레임 처리
    # =========================================================================
    while True:
        # =====================================================================
        # 1단계: 카메라에서 프레임 읽기
        # =====================================================================
        # video.read(): (성공여부, 이미지) 튜플 반환
        # _: 성공여부는 무시 (항상 성공한다고 가정)
        _, img = video.read()
        
        # =====================================================================
        # 2단계: 이미지 좌우 반전 (거울 효과)
        # =====================================================================
        # flip(img, 1): 좌우 반전
        # 사용자가 자신의 손을 보듯이 거울처럼 표시
        # 예: 오른손을 들면 화면에서도 오른쪽에 표시
        img = cv2.flip(img, 1)
        
        # =====================================================================
        # 3단계: 손 검출 및 추적
        # =====================================================================
        # detector.findHands(): MediaPipe로 손 검출
        # - img: 입력 이미지
        # - draw=True: 손 랜드마크와 연결선을 이미지에 그림
        # 
        # 반환값:
        # - hand: 검출된 손 정보 리스트 [손1, 손2, ...]
        # - img: 랜드마크가 그려진 이미지
        hand = detector.findHands(img, draw=True)
        
        # =====================================================================
        # 4단계: 제스처 아이콘 로드 (기본: unknown)
        # =====================================================================
        # 제스처를 시각적으로 표시하기 위한 아이콘 이미지
        gesture_pic = cv2.imread(file_path + "/gestures/unknown.png")
        
        # =====================================================================
        # 5단계: 제스처 초기값 설정
        # =====================================================================
        # gesture: 6개 손가락의 목표 위치 [엄지, 검지, 중지, 약지, 새끼, 엄지루트]
        # 초기값: [45000, 65535, 65535, 65535, 65535, 65535]
        # - 엄지: 45000 (약간 접힌 상태)
        # - 나머지: 65535 (완전히 접힌 상태)
        gesture = [45000, 65535, 65535, 65535, 65535, 65535]
        
        # =====================================================================
        # 6단계: 손이 감지된 경우 처리
        # =====================================================================
        if hand:
            # 첫 번째 손 정보 가져오기 (maxHands=1이므로 항상 1개)
            lmlist = hand[0]
            
            # 손 정보가 유효한지 확인
            if lmlist and lmlist[0]:
                try:
                    # =============================================================
                    # 6.1 손가락 펴짐/접힘 상태 계산
                    # =============================================================
                    # fingersUp(): 각 손가락이 펴져 있는지 확인
                    # 반환값: [엄지, 검지, 중지, 약지, 새끼, 엄지회전]
                    # 예: [1, 1, 0, 0, 0, 0.5] 
                    #     → 엄지와 검지는 펴짐, 나머지는 접힘, 엄지회전 50%
                    finger_up = detector.fingersUp(lmlist[0])
                    
                    # =============================================================
                    # 6.2 잘못된 제스처 필터링
                    # =============================================================
                    # finger_up[1:5]: 검지~새끼 상태만 확인
                    # [0, 1, 0, 0]: 검지만 펴진 상태
                    # 이 패턴이 아닌 경우만 처리 (검지만 펴진 건 특수 제스처)
                    if finger_up[1:5] != [0, 1, 0, 0]:
                        # 각 손가락의 목표 위치 계산
                        # 공식: gesture[i] = gesture[i] * (1 - finger_up[i])
                        # 
                        # 손가락이 펴져 있으면 (finger_up[i] = 1):
                        #   gesture[i] = gesture[i] * (1 - 1) = 0 (펴짐)
                        # 손가락이 접혀 있으면 (finger_up[i] = 0):
                        #   gesture[i] = gesture[i] * (1 - 0) = gesture[i] (접힘)
                        for i in range(len(finger_up)):
                            gesture[i] = int(gesture[i] * (1 - finger_up[i]))
                            
                except Exception as e:
                    # 손 추적 중 예외 발생 시 출력
                    print(f"손 추적 오류: {str(e)}")
                
                # =============================================================
                # 6.3 제스처 패턴 인식 및 아이콘 선택
                # =============================================================
                # finger_up[:5]: 엄지~새끼 5개 손가락 상태만 확인
                # (엄지 회전 값은 제외)
                
                # 제스처 0: 주먹 (모든 손가락 접힘)
                if finger_up[:5] == [0, 0, 0, 0, 0]:
                    gesture_pic = cv2.imread(file_path + "/gestures/0.png")
                
                # 제스처 1: 검지만 펴짐 (손가락 1개)
                elif finger_up[:5] == [0, 1, 0, 0, 0]:
                    gesture_pic = cv2.imread(file_path + "/gestures/1.png")
                
                # 제스처 2: 검지+중지 (손가락 2개)
                elif finger_up[:5] == [0, 1, 1, 0, 0]:
                    gesture_pic = cv2.imread(file_path + "/gestures/2.png")
                
                # 제스처 3: 검지+중지+약지 (손가락 3개)
                elif finger_up[:5] == [0, 1, 1, 1, 0]:
                    gesture_pic = cv2.imread(file_path + "/gestures/3.png")
                
                # 제스처 4: 검지~새끼 (손가락 4개)
                elif finger_up[:5] == [0, 1, 1, 1, 1]:
                    gesture_pic = cv2.imread(file_path + "/gestures/4.png")
                
                # 제스처 5: 모든 손가락 펴짐 (손가락 5개)
                elif finger_up[:5] == [1, 1, 1, 1, 1]:
                    gesture_pic = cv2.imread(file_path + "/gestures/5.png")
        
        else:
            # =================================================================
            # 7단계: 손이 감지되지 않은 경우
            # =================================================================
            # 모든 손가락을 펴진 상태로 설정
            gesture = [0, 0, 0, 0, 0, 0]
        
        # =====================================================================
        # 8단계: 제스처 아이콘을 화면에 오버레이
        # =====================================================================
        if gesture_pic.any():
            # 아이콘 크기 조정: 161x203 픽셀
            gesture_pic = cv2.resize(gesture_pic, (161, 203))
            
            # 이미지 왼쪽 상단에 아이콘 배치
            # img[0:203, 0:161]: 왼쪽 상단 161x203 영역
            img[0:203, 0:161] = gesture_pic
        
        # =====================================================================
        # 9단계: 엄지 간섭 방지 알고리즘
        # =====================================================================
        # 문제: 엄지와 다른 손가락이 동시에 움직이면 ROHand가 헷갈림
        # 해결: 검지 위치가 변경되면 일정 시간 동안 엄지 움직임을 지연
        
        # 조건: 엄지가 접혀 있고(gesture[0] > 0) 엄지 루트가 회전 중(gesture[5] > 0)
        if gesture[0] > 0 and gesture[5] > 0:
            # 검지 위치가 변경되었는지 확인
            if prev_index_pos != gesture[1]:
                # 위치 변경 감지 → 타이머 리셋
                timer = 0
                prev_index_pos = gesture[1]
            
            # 타이머가 0일 때 원래 엄지 위치 저장
            if timer == 0:
                original_thumb_pos = gesture[0]
            
            # 타이머 증가
            timer += 1
            
            # interval(10프레임) 동안 엄지를 펴진 상태로 유지
            if timer <= interval:
                gesture[0] = 0  # 엄지 임시로 펴기
            else:
                # interval 경과 후 원래 엄지 위치 복원
                gesture[0] = original_thumb_pos
        else:
            # 엄지가 펴져 있거나 엄지 루트가 회전하지 않으면
            if timer > 0:
                # 저장된 엄지 위치 복원
                gesture[0] = original_thumb_pos
            # 타이머 리셋
            timer = 0
        
        # =====================================================================
        # 10단계: 제스처 데이터를 큐에 전달
        # =====================================================================
        # 큐가 가득 차지 않았으면 데이터 추가
        if not gesture_queue.full():
            gesture_queue.put(gesture)
        
        # =====================================================================
        # 11단계: 카메라 이미지를 큐에 전달
        # =====================================================================
        # 큐가 가득 차지 않았으면 이미지 추가
        if not image_queue.full():
            image_queue.put(img)
        
        # =====================================================================
        # 12단계: 루프 반복
        # =====================================================================
        # while True이므로 무한 반복
        # 메인 스레드가 종료되면 daemon 스레드로 자동 종료됨

# =============================================================================
# 메인 함수
# =============================================================================

def main():
    """
    메인 제어 함수
    
    전체 프로그램의 흐름을 제어하는 핵심 함수입니다.
    
    실행 단계:
    ----------
    1. ModBus 시리얼 포트 연결
    2. 카메라 스레드 시작
    3. 큐에서 제스처 데이터 수신
    4. 제스처 변경 감지
    5. ROHand에 제어 명령 전송
    6. 화면에 영상 표시
    7. 'q' 키 입력 시 종료
    
    스레드 구조:
    -----------
    [메인 스레드]                    [카메라 스레드]
         │                                │
         │                                ↓
         │                          카메라 읽기
         │                                │
         │                                ↓
         │                           손 추적
         │                                │
         │                                ↓
         │                          제스처 인식
         │                                │
         │                                ↓
         ↓                           gesture_queue
    gesture 수신 ←────────────────── put(gesture)
         │
         ↓
    제스처 변경?
         │
         ↓ Yes
    ROHand 제어
         │
         ↓
    화면 표시
         │
         ↓
    'q' 입력?
         │
         ↓ Yes
       종료
    """
    
    # =========================================================================
    # 1단계: ModBus 시리얼 포트 연결
    # =========================================================================
    print("\n" + "="*60)
    print("ROHand Gesture Control 시작")
    print("="*60)
    print("\n[단계 1] 시리얼 포트 검색 중...")
    
    # 포트 자동 감지: CH340 또는 USB
    comport = find_comport("CH340") or find_comport("USB")
    
    if comport is None:
        print("\n✗ 시리얼 포트를 찾을 수 없습니다!")
        exit(-1)
    
    # ModBus 클라이언트 생성
    print(f"\n[단계 2] ModBus 클라이언트 생성...")
    print(f"  - 포트: {comport}")
    print(f"  - Baud Rate: 115200")
    
    client = ModbusSerialClient(
        comport,
        FramerType.RTU,
        115200
    )
    
    # 연결 시도
    print(f"\n[단계 3] ROHand 연결 시도...")
    if not client.connect():
        print("\n✗ 연결 실패!")
        print("连接Modbus设备失败\nFailed to connect to Modbus device")
        exit(-1)
    
    print("✓ ROHand 연결 성공!")
    
    # =========================================================================
    # 2단계: 변수 초기화
    # =========================================================================
    # 이전 제스처 저장 (변경 감지용)
    prev_gesture = [0, 0, 0, 0, 0, 0]
    
    # 마지막 제스처 변경 시간 (엄지 지연 제어용)
    last_time = time.time()
    
    # =========================================================================
    # 3단계: 카메라 스레드 시작
    # =========================================================================
    print(f"\n[단계 4] 카메라 스레드 시작...")
    
    # threading.Thread: 새 스레드 생성
    # - target=camera_thread: 실행할 함수
    # - daemon=True: 메인 스레드 종료 시 자동 종료
    threading.Thread(target=camera_thread, daemon=True).start()
    
    print("✓ 카메라 스레드 실행 중")
    
    print("\n" + "="*60)
    print("손동작으로 ROHand를 제어하세요!")
    print("종료: 'q' 키를 누르세요")
    print("="*60 + "\n")
    
    # =========================================================================
    # 4단계: 메인 루프 (제스처 수신 및 ROHand 제어)
    # =========================================================================
    while True:
        # =====================================================================
        # 4.1 큐에서 제스처 데이터 수신 (블로킹)
        # =====================================================================
        # gesture_queue.get(): 큐에서 데이터를 꺼냄
        # 데이터가 없으면 대기 (블로킹)
        gesture = gesture_queue.get()
        
        # =====================================================================
        # 4.2 큐에서 카메라 이미지 수신 (논블로킹)
        # =====================================================================
        # image_queue.empty(): 큐가 비어있는지 확인
        if not image_queue.empty():
            # 이미지 꺼내기
            img = image_queue.get()
            
            # 화면에 안내 텍스트 추가
            # putText(이미지, 텍스트, 위치, 폰트, 크기, 색상, 두께)
            cv2.putText(
                img,                            # 대상 이미지
                "Try with gestures",            # 표시할 텍스트
                (16, 272),                      # 위치 (x, y)
                cv2.FONT_HERSHEY_SIMPLEX,       # 폰트
                2,                              # 글자 크기
                (0, 255, 0),                    # 색상 (BGR: 녹색)
                5                               # 두께
            )
            
            # 화면에 이미지 표시
            cv2.imshow("Video", img)
        
        # =====================================================================
        # 4.3 제스처 변경 감지
        # =====================================================================
        if (prev_gesture != gesture):
            # =================================================================
            # 4.3.1 엄지 지연 제어
            # =================================================================
            # 제스처가 0.7초 이내에 변경되면 엄지는 펴진 상태 유지
            # 목적: 빠른 제스처 전환 시 엄지가 천천히 반응하도록
            current_time = time.time()
            
            if (current_time - last_time < 0.7):
                # 0.7초 이내 → 엄지 펴진 상태로
                gesture[0] = 0
            else:
                # 0.7초 경과 → 시간 업데이트
                last_time = current_time
            
            # =================================================================
            # 4.3.2 ROHand에 제어 명령 전송
            # =================================================================
            # write_registers: ModBus로 목표 위치 전송
            # - address: ROH_FINGER_POS_TARGET0 (1135)
            # - values: gesture (6개 손가락의 목표 위치)
            if not write_registers(client, ROH_FINGER_POS_TARGET0, gesture):
                print("✗ 목표 위치 전송 실패")
                print("写入目标位置失败\nFailed to write target position")
            
            # 이전 제스처 업데이트
            prev_gesture = gesture
        
        # =====================================================================
        # 4.4 키보드 입력 확인
        # =====================================================================
        # waitKey(1): 1ms 동안 키 입력 대기
        # 0xFF: 키 코드 마스크
        # ord('q'): 'q' 키의 ASCII 코드
        if cv2.waitKey(1) & 0xFF == ord('q'):
            print("\n'q' 키가 입력되었습니다. 종료합니다...")
            break
    
    # =========================================================================
    # 5단계: 정리 및 종료
    # =========================================================================
    print("\n[종료 처리]")
    
    # 카메라 리소스 해제
    print("  - 카메라 종료...")
    video.release()
    
    # OpenCV 윈도우 닫기
    print("  - 윈도우 닫기...")
    cv2.destroyAllWindows()
    
    # ModBus 연결 종료
    print("  - ROHand 연결 종료...")
    client.close()
    
    print("\n" + "="*60)
    print("프로그램이 정상적으로 종료되었습니다.")
    print("="*60 + "\n")

# =============================================================================
# 프로그램 진입점
# =============================================================================

if __name__ == "__main__":
    """
    프로그램 시작점
    
    실행 순서:
    1. main() 함수 호출
    2. ROHand 연결
    3. 카메라 스레드 시작
    4. 제스처 인식 및 제어 루프
    5. 'q' 키로 종료
    """
    try:
        main()
    except KeyboardInterrupt:
        # Ctrl+C로 강제 종료 시
        print("\n\n프로그램이 중단되었습니다.")
    except Exception as e:
        # 예외 발생 시
        print(f"\n오류 발생: {e}")
    finally:
        # 항상 실행: 리소스 정리
        try:
            video.release()
            cv2.destroyAllWindows()
        except:
            pass